<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Foldable (control.Control.Foldable)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">control</a> &#x00BB; <a href="../index.html">Control</a> &#x00BB; Foldable</nav><h1>Module type <code>Control.Foldable</code></h1><p>A container type with the ability to fold on itself.</p><p>The <code>Foldable</code> interface describes the operations that sequentially iterate over the elements in a parameterised unary type <code>'a t</code> and, starting with an initial value <code>init</code>, combine the elements togather, using a provided function <code>f</code>, into a single result.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt></dl><dl><dt class="spec value" id="val-foldl"><a href="#val-foldl" class="anchor"></a><code><span class="keyword">val</span> foldl : <span class="arg"><span>(<span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'r</span> <span>&#45;&gt;</span> </span><span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'r</span> <span>&#45;&gt;</span> </span><span class="arg"><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> </span><span class="type-var">'r</span></code></dt><dd><p><code>foldl f init self</code> uses <code>f</code> to sequentially, from left to right, combine the elements of the container <code>self</code> with an accumulator value <code>init</code>.</p><pre><code class="ml">assert (Array.foldl (+) 0 [|1; 2; 3|] = 6);
assert (List.foldl List.add [] [1; 2; 3] = [3; 2; 1]);</code></pre></dd></dl><dl><dt class="spec value" id="val-foldr"><a href="#val-foldr" class="anchor"></a><code><span class="keyword">val</span> foldr : <span class="arg"><span>(<span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'r</span> <span>&#45;&gt;</span> </span><span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'r</span> <span>&#45;&gt;</span> </span><span class="arg"><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> </span><span class="type-var">'r</span></code></dt><dd><p><code>foldr f init self</code> is the same as <code>foldl</code> but performs the folding from right to left.</p><pre><code class="ml">assert (Array.foldr (+) 0 [|1; 2; 3|] = 6);
assert (List.foldr List.add [] [1; 2; 3] = [1; 2; 3]);</code></pre></dd></dl><dl><dt class="spec value" id="val-foldk"><a href="#val-foldk" class="anchor"></a><code><span class="keyword">val</span> foldk : <span class="arg"><span>(<span class="arg"><span class="type-var">'a</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'r</span> <span>&#45;&gt;</span> </span><span class="arg"><span>(<span class="arg"><span class="type-var">'r</span> <span>&#45;&gt;</span> </span><span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> </span><span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> </span><span class="arg"><span class="type-var">'r</span> <span>&#45;&gt;</span> </span><span class="arg"><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> </span><span class="type-var">'r</span></code></dt><dd><p><code>foldk f init self</code> is the same as <code>foldl</code> but with early termination support. The function <code>f</code> is given a continuation argument <code>('r -&gt; 'r)</code> that <code>f</code> can call to keep folding with an intermediate accumulator, or return the accumulator to immediately stop without consuming more elements.</p><pre><code class="ml">let count_until_0 =
  List.foldk
    (fun x count continue -&gt;
       if x = 0 then count
       else continue (count + 1))
    0
    [5; 22; 10; 0; 4; 3; 14; 72; 92]
in assert (count_until_0 = 3);</code></pre></dd></dl></div></body></html>