<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Control (control.Control)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">control</a> &#x00BB; Control</nav><h1>Module <code>Control</code></h1><p>Functional control abstractions.</p><p>This library implements common functional idioms and abstractions such as monoids, functors, monads, <i>etc</i>.</p><h4 id="examples"><a href="#examples" class="anchor"></a>Examples</h4><p>As an example consider the implementation of the following module that implement operations and interfaces for optional values:</p><pre><code>open Control

module Option : sig
  type 'a t = 'a option = None | Some of 'a

  val some : 'a -&gt; 'a option
  val none : 'a option

  val to_result : error: 'b -&gt; 'a option -&gt; ('a, 'b) result

  (** {2 Implemented Interfaces} *)

  include Monad.Extension       with type 'a t := 'a option
  include Functor.Extension     with type 'a t := 'a option
  include Applicative.Extension with type 'a t := 'a option
end = struct
  type 'a t = 'a option = None | Some of 'a

  let some a = Some a
  let none = None

  (* Interfaces *)

  module Monad_instance = struct
    type 'a t = 'a option

    let return x = Some x

    let bind f self =
      match self with
      | Some x -&gt; f x
      | None -&gt; None
  end

  module Functor_instance = Monad.To_functor(Monad_instance)
  module Applicative_instance = Monad.To_applicative(Monad_instance)

  include Monad.Extend(Monad_instance)
  include Functor.Extend(Functor_instance)
  include Applicative.Extend(Applicative_instance)
end</code></pre><nav class="toc"><ul><li><a href="#types">Abstract Types</a></li><li><a href="#semigroup">Semigroup</a><ul><li><a href="#examples">Examples</a></li></ul></li><li><a href="#monoid">Monoid</a><ul><li><a href="#examples">Examples</a></li></ul></li><li><a href="#functor">Functor</a></li><li><a href="#applicatives">Applicatives</a></li><li><a href="#alternative">Alternative</a></li><li><a href="#monad">Monad</a></li><li><a href="#monad2">Monad2</a></li><li><a href="#state-monad">State Monad</a></li></ul></nav></header><section><header><h2 id="types"><a href="#types" class="anchor"></a>Abstract Types</h2><p>Module types used to represent abstract types. These are normally used as argument types in functors.</p></header><article class="spec module-type" id="module-type-Type0"><a href="#module-type-Type0" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Type0/index.html">Type0</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Type1"><a href="#module-type-Type1" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Type1/index.html">Type1</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Type2"><a href="#module-type-Type2" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Type2/index.html">Type2</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Type3"><a href="#module-type-Type3" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Type3/index.html">Type3</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Type"><a href="#module-type-Type" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Type/index.html">Type</a> = <a href="index.html#module-type-Type0">Type0</a></code></article></section><section><header><h2 id="semigroup"><a href="#semigroup" class="anchor"></a>Semigroup</h2><p>A type is a <code>Semigroup</code> if it implements an associative operation.</p><p>Instances are required to satisfy the following law:</p><ul><li><em>Associativity</em>: <code>(a &lt;+&gt; b) &lt;+&gt; c = a &lt;+&gt; (b &lt;+&gt; c)</code></li></ul></header><section><header><h4 id="examples"><a href="#examples" class="anchor"></a>Examples</h4><pre><code>open Control

module Int_semigroup : Semigroup0 = struct
  let (&lt;+&gt;) a b = a + b
end

module List_semigroup : Semigroup1 = struct
  let (&lt;+&gt;) a b = List.append a b
end

let () =
  assert (Int_semigroup.(100 &lt;+&gt; 42) = 142);
  assert (List_semigroup.([1; 2] &lt;+&gt; [3; 4; 5]) = [1; 2; 3; 4; 5])</code></pre></header><article class="spec module-type" id="module-type-Semigroup0"><a href="#module-type-Semigroup0" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Semigroup0/index.html">Semigroup0</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Semigroup1"><a href="#module-type-Semigroup1" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Semigroup1/index.html">Semigroup1</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Semigroup"><a href="#module-type-Semigroup" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Semigroup/index.html">Semigroup</a> = <a href="index.html#module-type-Semigroup0">Semigroup0</a></code></article></section></section><section><header><h2 id="monoid"><a href="#monoid" class="anchor"></a>Monoid</h2><p>Types that implement an associative binary operation, along with a neutral element for that operation. Monoids extend semigroups.</p><p>Instances are required to satisfy the following law:</p><ul><li><em>Associativity of <code>&lt;+&gt;</code></em>: <code>(a &lt;+&gt; b) &lt;+&gt; c = a &lt;+&gt; (b &lt;+&gt; c)</code>.</li><li><em>Neutral for <code>&lt;+&gt;</code></em>: <code>a &lt;+&gt; neutral = a</code> and <code>neutral &lt;+&gt; = a</code>.</li></ul></header><section><header><h4 id="examples"><a href="#examples" class="anchor"></a>Examples</h4><pre><code>open Control

module Int_monoid : Monoid0 = struct
  let neutral = 0
  let (&lt;+&gt;) a b = a + b
end

module List_monoid : Monoid1 = struct
  let neutral = []
  let (&lt;+&gt;) a b = List.append a b
end

let () =
  assert (Int_semigroup.(100 &lt;+&gt; 42) = 142);
  assert (List_semigroup.([1; 2] &lt;+&gt; [3; 4; 5]) = [1; 2; 3; 4; 5])</code></pre></header><article class="spec module-type" id="module-type-Monoid0"><a href="#module-type-Monoid0" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Monoid0/index.html">Monoid0</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Monoid1"><a href="#module-type-Monoid1" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Monoid1/index.html">Monoid1</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Monoid"><a href="#module-type-Monoid" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Monoid/index.html">Monoid</a> = <a href="index.html#module-type-Monoid0">Monoid0</a></code></article></section></section><section><header><h2 id="functor"><a href="#functor" class="anchor"></a>Functor</h2><p>A type is a <code>Functor</code> if it provides some context or structure for values of type <code>'a</code> and allows the values to be mapped over and transformed into type <code>'b</code>.</p><p>The mapping function may only see each itm independently - not the whole structure; it may also not change the structure, only the values being mapped.</p></header><article class="spec module-type" id="module-type-Functor1"><a href="#module-type-Functor1" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Functor1/index.html">Functor1</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-Functor1"><a href="#module-Functor1" class="anchor"></a><code><span class="keyword">module </span><a href="Functor1/index.html">Functor1</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Functor0"><a href="#module-type-Functor0" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Functor0/index.html">Functor0</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-Functor0"><a href="#module-Functor0" class="anchor"></a><code><span class="keyword">module </span><a href="Functor0/index.html">Functor0</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Functor2"><a href="#module-type-Functor2" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Functor2/index.html">Functor2</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-Functor2"><a href="#module-Functor2" class="anchor"></a><code><span class="keyword">module </span><a href="Functor2/index.html">Functor2</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Functor"><a href="#module-type-Functor" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Functor/index.html">Functor</a> = <a href="index.html#module-type-Functor1">Functor1</a></code></article><article class="spec module" id="module-Functor"><a href="#module-Functor" class="anchor"></a><code><span class="keyword">module </span>Functor = <a href="index.html#module-Functor1">Functor1</a></code></article></section><section><header><h2 id="applicatives"><a href="#applicatives" class="anchor"></a>Applicatives</h2><p>A type is an <code>Applicative</code> if it is a <code>Functor</code>, and also permits arbitrary values and a mapping function to be exist in its context. More simply, this allows for chaining of computations inside some context.</p><p>For example, if the functor in question is the List type and we have a list of functions which take an integer and produce a boolean, and another list of integers, then we can write:</p><pre><code>func_list &lt;*&gt; int_list</code></pre><p>to apply all the functions in the first list to all the ints in the second list to produce a list of all results.</p></header><article class="spec module-type" id="module-type-Applicative1"><a href="#module-type-Applicative1" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Applicative1/index.html">Applicative1</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-Applicative1"><a href="#module-Applicative1" class="anchor"></a><code><span class="keyword">module </span><a href="Applicative1/index.html">Applicative1</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Applicative2"><a href="#module-type-Applicative2" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Applicative2/index.html">Applicative2</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-Applicative2"><a href="#module-Applicative2" class="anchor"></a><code><span class="keyword">module </span><a href="Applicative2/index.html">Applicative2</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Applicative"><a href="#module-type-Applicative" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Applicative/index.html">Applicative</a> = <a href="index.html#module-type-Applicative1">Applicative1</a></code></article><article class="spec module" id="module-Applicative"><a href="#module-Applicative" class="anchor"></a><code><span class="keyword">module </span>Applicative = <a href="index.html#module-Applicative1">Applicative1</a></code></article></section><section><header><h2 id="alternative"><a href="#alternative" class="anchor"></a>Alternative</h2><p>A type is an <code>Alternative</code> if it is also an <code>Applicative</code>. The name &quot;Alternative&quot; suggests a common use case for this interface: functor computations which allow for a limited form of choice. How an <code>Alternative</code> instance decides between two values is what defines it.</p></header><article class="spec module-type" id="module-type-Alternative1"><a href="#module-type-Alternative1" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Alternative1/index.html">Alternative1</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-Alternative1"><a href="#module-Alternative1" class="anchor"></a><code><span class="keyword">module </span><a href="Alternative1/index.html">Alternative1</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Alternative2"><a href="#module-type-Alternative2" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Alternative2/index.html">Alternative2</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-Alternative2"><a href="#module-Alternative2" class="anchor"></a><code><span class="keyword">module </span><a href="Alternative2/index.html">Alternative2</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Alternative"><a href="#module-type-Alternative" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Alternative/index.html">Alternative</a> = <a href="index.html#module-type-Alternative1">Alternative1</a></code></article><article class="spec module" id="module-Alternative"><a href="#module-Alternative" class="anchor"></a><code><span class="keyword">module </span>Alternative = <a href="index.html#module-Alternative1">Alternative1</a></code></article></section><section><header><h2 id="monad"><a href="#monad" class="anchor"></a>Monad</h2><p>Types that support sequential composition.</p></header><article class="spec module-type" id="module-type-Monad1"><a href="#module-type-Monad1" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Monad1/index.html">Monad1</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-Monad1"><a href="#module-Monad1" class="anchor"></a><code><span class="keyword">module </span><a href="Monad1/index.html">Monad1</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article></section><section><header><h2 id="monad2"><a href="#monad2" class="anchor"></a>Monad2</h2></header><article class="spec module-type" id="module-type-Monad2"><a href="#module-type-Monad2" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Monad2/index.html">Monad2</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-Monad2"><a href="#module-Monad2" class="anchor"></a><code><span class="keyword">module </span><a href="Monad2/index.html">Monad2</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Monad"><a href="#module-type-Monad" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Monad/index.html">Monad</a> = <a href="index.html#module-type-Monad1">Monad1</a></code></article><article class="spec module" id="module-Monad"><a href="#module-Monad" class="anchor"></a><code><span class="keyword">module </span>Monad = <a href="index.html#module-Monad1">Monad1</a></code></article></section><section><header><h2 id="state-monad"><a href="#state-monad" class="anchor"></a>State Monad</h2></header><article class="spec module-type" id="module-type-State"><a href="#module-type-State" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-State/index.html">State</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-State"><a href="#module-State" class="anchor"></a><code><span class="keyword">module </span><a href="State/index.html">State</a> : <span class="keyword">functor</span> (<a href="State/argument-1-S/index.html">S</a> : <a href="index.html#module-type-Type">Type</a>) -&gt; <a href="index.html#module-type-State">State</a><span class="keyword"> with </span><span class="keyword">type </span><a href="State/index.html#type-state">state</a><span class="keyword"> = </span><a href="State/argument-1-S/index.html#type-t">S.t</a></code></article><article class="spec module-type" id="module-type-State1"><a href="#module-type-State1" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-State1/index.html">State1</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-State1"><a href="#module-State1" class="anchor"></a><code><span class="keyword">module </span><a href="State1/index.html">State1</a> : <span class="keyword">functor</span> (<a href="State1/argument-1-S/index.html">S</a> : <a href="index.html#module-type-Type1">Type1</a>) -&gt; <a href="index.html#module-type-State1">State1</a><span class="keyword"> with </span><span class="keyword">type </span>'x <a href="State1/index.html#type-state">state</a><span class="keyword"> = </span><span class="type-var">'x</span> <a href="State1/argument-1-S/index.html#type-t">S.t</a></code></article><article class="spec module-type" id="module-type-StateT"><a href="#module-type-StateT" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-StateT/index.html">StateT</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-StateT"><a href="#module-StateT" class="anchor"></a><code><span class="keyword">module </span><a href="StateT/index.html">StateT</a> : <span class="keyword">functor</span> (<a href="StateT/argument-1-S/index.html">S</a> : <a href="index.html#module-type-Type">Type</a>) -&gt; <span class="keyword">functor</span> (<a href="StateT/argument-2-M/index.html">M</a> : <a href="index.html#module-type-Monad1">Monad1</a>) -&gt; <a href="index.html#module-type-StateT">StateT</a><span class="keyword"> with </span><span class="keyword">type </span><a href="StateT/index.html#type-state">state</a><span class="keyword"> = </span><a href="StateT/argument-1-S/index.html#type-t">S.t</a><span class="keyword"> and </span><span class="keyword">type </span>'a <a href="StateT/index.html#type-monad">monad</a><span class="keyword"> = </span><span class="type-var">'a</span> <a href="StateT/argument-2-M/index.html#type-t">M.t</a></code></article><article class="spec module-type" id="module-type-State1T"><a href="#module-type-State1T" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-State1T/index.html">State1T</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module" id="module-State1T"><a href="#module-State1T" class="anchor"></a><code><span class="keyword">module </span><a href="State1T/index.html">State1T</a> : <span class="keyword">functor</span> (<a href="State1T/argument-1-S/index.html">S</a> : <a href="index.html#module-type-Type1">Type1</a>) -&gt; <span class="keyword">functor</span> (<a href="State1T/argument-2-M/index.html">M</a> : <a href="index.html#module-type-Monad1">Monad1</a>) -&gt; <a href="index.html#module-type-State1T">State1T</a><span class="keyword"> with </span><span class="keyword">type </span>'x <a href="State1T/index.html#type-state">state</a><span class="keyword"> = </span><span class="type-var">'x</span> <a href="State1T/argument-1-S/index.html#type-t">S.t</a><span class="keyword"> and </span><span class="keyword">type </span>'a <a href="State1T/index.html#type-monad">monad</a><span class="keyword"> = </span><span class="type-var">'a</span> <a href="State1T/argument-2-M/index.html#type-t">M.t</a></code></article><article class="spec module" id="module-IndexedState"><a href="#module-IndexedState" class="anchor"></a><code><span class="keyword">module </span><a href="IndexedState/index.html">IndexedState</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><article class="spec module-type" id="module-type-Foldable"><a href="#module-type-Foldable" class="anchor"></a><code><span class="keyword">module type </span><a href="module-type-Foldable/index.html">Foldable</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article><aside><p>Trivial identity type module.</p></aside><dl><dt class="spec value" id="val-scoped"><a href="#val-scoped" class="anchor"></a><code><span class="keyword">val </span>scoped : ((<span class="type-var">'a</span> <span>&#8209;&gt;</span> <span class="type-var">'b</span>) <span>&#8209;&gt;</span> <span class="type-var">'a</span>) <span>&#8209;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>scoped f</code> is the result of invocation of the function <code>f</code> with the ability to interrupt its execution and return some value. A special function <code>break</code> will be passed to <code>f</code> as an argument that can capture a value by (internally) raising an exception.</p><pre><code>let result =
  scoped (fun break -&gt;
    break &quot;hello&quot;;
    print &quot;this will not be printed&quot;) in
assert (result = &quot;hello&quot;)</code></pre></dd></dl></section></div></body></html>